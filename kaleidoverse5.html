<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Mirrorverse</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; cursor: grab; }
        body.grabbing { cursor: grabbing; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #333;
            font-family: sans-serif;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            pointer-events: none;
            user-select: none;
            text-transform: uppercase;
            font-size: 0.8rem;
            font-weight: bold;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h3>Mirrorverse Structure</h3>
        <p>Drag to warp perspective</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        // 1. SCENE SETUP (Bright White World)
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0); // White background
        scene.fog = new THREE.Fog(0xf0f0f0, 5, 40);   // White fog to blend distance

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // 2. LIGHTING (Bright Studio Lights)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // 3. MATERIALS
        // White "Building" material (Self-illuminated to stay bright)
        const buildingMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
        });

        // Silver/Chrome Accents
        const chromeMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xaaaaaa,
            metalness: 1.0,
            roughness: 0.1,
            clearcoat: 1.0
        });

        // Wireframe for "Blueprint" look
        const wireMaterial = new THREE.LineBasicMaterial({ color: 0x333333, opacity: 0.3, transparent: true });

        // 4. GENERATE THE "CITY" INSIDE THE KALEIDOSCOPE
        const cityGroup = new THREE.Group();
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const edges = new THREE.EdgesGeometry(geometry);

        // Create 200 random floating structures
        for (let i = 0; i < 200; i++) {
            // Mix of solid white blocks and chrome blocks
            const mat = Math.random() > 0.8 ? chromeMaterial : buildingMaterial;
            
            const mesh = new THREE.Mesh(geometry, mat);
            
            // Randomize position in a sphere around the camera
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const r = 4 + Math.random() * 20; // Distance from center

            mesh.position.x = r * Math.sin(phi) * Math.cos(theta);
            mesh.position.y = r * Math.sin(phi) * Math.sin(theta);
            mesh.position.z = r * Math.cos(phi);

            // Stretch them to look like shards or buildings
            mesh.scale.x = Math.random() * 2;
            mesh.scale.y = Math.random() * 10; // Tall
            mesh.scale.z = Math.random() * 2;
            
            mesh.lookAt(0,0,0); // Point towards center
            
            cityGroup.add(mesh);

            // Add wireframe outlines to some for architectural detail
            if (Math.random() > 0.5) {
                const line = new THREE.LineSegments(edges, wireMaterial);
                line.scale.copy(mesh.scale);
                line.position.copy(mesh.position);
                line.quaternion.copy(mesh.quaternion);
                cityGroup.add(line);
            }
        }
        scene.add(cityGroup);

        // 5. THE KALEIDOSCOPE POST-PROCESSING
        const KaleidoscopeShader = {
            uniforms: {
                'tDiffuse': { value: null },
                'sides': { value: 6.0 }, // 6 mirrors
                'angle': { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float sides;
                uniform float angle;
                varying vec2 vUv;

                void main() {
                    vec2 p = vUv - 0.5;
                    float r = length(p);
                    float a = atan(p.y, p.x) + angle;
                    float tau = 6.28318;
                    
                    // The Kaleidoscope folding math
                    a = mod(a, tau/sides);
                    a = abs(a - tau/sides/2.0);
                    
                    p = r * vec2(cos(a), sin(a));
                    
                    vec4 color = texture2D(tDiffuse, p + 0.5);
                    gl_FragColor = color;
                }
            `
        };

        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const kaleidoPass = new ShaderPass(KaleidoscopeShader);
        composer.addPass(kaleidoPass);

        // 6. INPUT LOGIC (Half Sensitivity)
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            document.body.classList.add('grabbing');
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        document.addEventListener('mouseup', () => { isDragging = false; document.body.classList.remove('grabbing'); });
        document.addEventListener('mouseleave', () => { isDragging = false; document.body.classList.remove('grabbing'); });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const deltaMove = {
                x: e.clientX - previousMousePosition.x,
                y: e.clientY - previousMousePosition.y
            };

            const sensitivity = 0.002; 

            // Rotate the kaleidoscope
            kaleidoPass.uniforms['angle'].value += deltaMove.x * sensitivity;
            
            // Rotate the "City" around the camera
            cityGroup.rotation.y += deltaMove.x * 0.001;
            cityGroup.rotation.x += deltaMove.y * 0.001;

            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        // 7. ANIMATION LOOP
        function animate() {
            requestAnimationFrame(animate);
            // Slight idle movement for life
            // cityGroup.rotation.z += 0.0005;
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>