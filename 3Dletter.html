<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Letter 'A'</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #1a1a1a; /* Darker background for particle visibility */
            color: #f0f0f0;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display:block;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 10px;
            max-width: 400px;
            left: 50%;
            transform: translateX(-50%);
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="info">Generating 80,000 particles... This may take a moment.</div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';
        import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';

        // --- Basic Setup ---
        let scene, camera, renderer, controls, clock;
        let particles;
        let noise;
        const particleCount = 80000; // Increased particle count for density
        const particleInfo = [];

        // --- REMOVED: State Management for Distortion ---
        // let distortionState = 'IDLE'; 
        // ... (all related variables removed)

        // --- Main Functions ---
        init();
        // We now need to pass the clock to animate to get delta time for smooth animation
        function animateWrapper() {
            animate(clock);
        }
        // Small change here to call the wrapper
        // animate(); // old call
        
        // We will call animate in the font loader callback once particles are ready
        
        // Function to initialize the scene, camera, and renderer
        function init() {
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            noise = new ImprovedNoise();
            
            // --- Camera and Renderer ---
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 12;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // --- Load Font and Create Particle Targets ---
            const fontLoader = new FontLoader();
            // Using a serif font available in Three.js examples as a stand-in for Times New Roman
            fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.164.1/examples/fonts/gentilis_bold.typeface.json', function (font) {
                
                // 1. Create the Text Geometry for the letter 'A'
                const textGeometry = new TextGeometry('A', {
                    font: font,
                    size: 8,
                    height: 2, // This gives the letter depth
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.3,
                    bevelSize: 0.1,
                    bevelOffset: 0,
                    bevelSegments: 5
                });
                
                // Center the geometry so it rotates around its middle
                textGeometry.center();

                // 2. Create a temporary mesh to sample points from
                const tempMesh = new THREE.Mesh(textGeometry);

                // --- NEW VOLUME FILLING LOGIC ---
                // A. Compute the bounding box to know where to generate points
                tempMesh.geometry.computeBoundingBox();
                const bbox = tempMesh.geometry.boundingBox;

                // B. Setup Raycaster to check if points are inside the mesh
                const raycaster = new THREE.Raycaster();
                const direction = new THREE.Vector3(0, 0, 1); // An arbitrary direction to cast rays

                // 3. Create the InstancedMesh for particles
                const particleGeometry = new THREE.SphereGeometry(0.025, 4, 4); // Smaller particles
                const particleMaterial = new THREE.MeshStandardMaterial({
                    color: 0xC0C0C0,
                    roughness: 0.6,
                    metalness: 0.2
                });
                particles = new THREE.InstancedMesh(particleGeometry, particleMaterial, particleCount);

                // 4. Sample points INSIDE the volume and set particle info
                const targetPosition = new THREE.Vector3();
                let pointsFound = 0;
                while (pointsFound < particleCount) {
                    // Generate a random point within the bounding box
                    targetPosition.set(
                        THREE.MathUtils.randFloat(bbox.min.x, bbox.max.x),
                        THREE.MathUtils.randFloat(bbox.min.y, bbox.max.y),
                        THREE.MathUtils.randFloat(bbox.min.z, bbox.max.z)
                    );

                    // Cast a ray from the point to check if it's inside
                    raycaster.set(targetPosition, direction);
                    const intersections = raycaster.intersectObject(tempMesh);

                    // If the number of intersections is odd, the point is inside the volume
                    if (intersections.length % 2 === 1) {
                        const i = pointsFound;
                        particleInfo.push({
                            target: targetPosition.clone(),
                            journey: {
                               currentIndex: i,
                               nextIndex: Math.floor(Math.random() * particleCount),
                               progress: 0.0,
                               speed: 0.05 + Math.random() * 0.05
                            },
                            initial: new THREE.Vector3(
                                (Math.random() - 0.5) * 30,
                                (Math.random() - 0.5) * 30,
                                (Math.random() - 0.5) * 30
                            )
                        });
                        pointsFound++;
                    }
                }
                
                // --- UPDATE ---
                // Change the info text now that the heavy calculation is done
                document.getElementById('info').textContent = "Particles forming the letter 'A'. Drag to rotate.";
                
                scene.add(particles);

                // Start the animation loop ONLY after the font and particles are ready
                animate(); 
            });

            // --- Controls ---
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize, false);
        }

        // --- REMOVED: triggerNewDistortion function ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // --- Animation Loop (Reverted and modified) ---
        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            const deltaTime = clock.getDelta(); // Get time since last frame for smooth speed

            // Check if particles have been initialized (font has loaded)
            if (particles) {
                const dummy = new THREE.Object3D();
                const formationAlpha = Math.min(elapsedTime / 5.0, 1.0);

                // --- Parameters remain the same ---
                const distortionNoiseSpeed = 0.8;
                const distortionNoiseScale = 0.5; 
                const distortionNoiseStrength = 0.8; 
                const maskNoiseSpeed = 0.2;
                const maskNoiseScale = 0.2;
                const energyNoiseSpeed = 3.0;
                const energyNoiseScale = 2.5; 
                const energyNoiseStrength = 0.15;

                for (let i = 0; i < particleCount; i++) {
                    const info = particleInfo[i];
                    
                    // --- NEW JOURNEY LOGIC ---
                    // 1. Advance the particle's journey progress
                    info.journey.progress += info.journey.speed * deltaTime;

                    // 2. If journey is complete, start a new one
                    if (info.journey.progress >= 1.0) {
                        info.journey.progress = 0.0;
                        info.journey.currentIndex = info.journey.nextIndex;
                        info.journey.nextIndex = Math.floor(Math.random() * particleCount);
                    }
                    
                    // 3. Determine the current base position by interpolating between journey points
                    const startPoint = particleInfo[info.journey.currentIndex].target;
                    const endPoint = particleInfo[info.journey.nextIndex].target;
                    const journeyPos = new THREE.Vector3().lerpVectors(startPoint, endPoint, info.journey.progress);

                    // 4. The overall position starts from the initial random spot and moves to its journeying spot
                    const formingPos = new THREE.Vector3().lerpVectors(info.initial, journeyPos, formationAlpha);
                    
                    const p = info.target; // Noise is still based on the original target for stability

                    // --- Distortion and Energy logic remains the same, but is applied to the new moving base position ---
                    const maskValue = noise.noise(p.x * maskNoiseScale, p.y * maskNoiseScale, elapsedTime * maskNoiseSpeed);
                    const localDistortionStrength = Math.max(0, maskValue);

                    const distortionVec = new THREE.Vector3(
                        noise.noise(p.x * distortionNoiseScale + elapsedTime * distortionNoiseSpeed, p.y * distortionNoiseScale, elapsedTime * distortionNoiseSpeed),
                        noise.noise(p.y * distortionNoiseScale + elapsedTime * distortionNoiseSpeed, p.z * distortionNoiseScale, elapsedTime * distortionNoiseSpeed),
                        noise.noise(p.z * distortionNoiseScale + elapsedTime * distortionNoiseSpeed, p.x * distortionNoiseScale, elapsedTime * distortionNoiseSpeed)
                    );
                    distortionVec.multiplyScalar(distortionNoiseStrength * localDistortionStrength * formationAlpha);
                    
                    const energyVec = new THREE.Vector3(
                        noise.noise(p.x * energyNoiseScale, p.y * energyNoiseScale, elapsedTime * energyNoiseSpeed),
                        noise.noise(p.y * energyNoiseScale, p.z * energyNoiseScale, elapsedTime * energyNoiseSpeed),
                        noise.noise(p.z * energyNoiseScale, p.x * energyNoiseScale, elapsedTime * energyNoiseSpeed)
                    );
                    energyVec.multiplyScalar(energyNoiseStrength * formationAlpha);

                    dummy.position.copy(formingPos).add(energyVec).add(distortionVec);

                    dummy.updateMatrix();
                    particles.setMatrixAt(i, dummy.matrix);
                }
                particles.instanceMatrix.needsUpdate = true;
            }

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>



